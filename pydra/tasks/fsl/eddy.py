"""
eddy
====

Correct for artifacts induced by Eddy currents and subject motion.
"""

import os

import attrs

import pydra

__all__ = ["Eddy"]


@attrs.define(slots=False, kw_only=True)
class EddySpec(pydra.specs.ShellSpec):
    """Specifications for eddy."""

    # Parameters that specify input files.
    input_image: os.PathLike = attrs.field(
        metadata={
            "help_string": (
                "input image as a 4D volume of all images acquired in the diffusion protocol"
            ),
            "mandatory": True,
            "argstr": "--imain",
        }
    )

    mask_image: os.PathLike = attrs.field(
        metadata={
            "help_string": "brain mask as a single volume image",
            "mandatory": True,
            "argstr": "--mask",
        }
    )

    acqp_file: os.PathLike = attrs.field(
        metadata={
            "help_string": "acquisition parameters for the diffusion protocol",
            "mandatory": True,
            "argstr": "--acqp",
        }
    )

    index_file: os.PathLike = attrs.field(
        metadata={
            "help_string": "mapping from volume index to acquisition parameters",
            "mandatory": True,
            "argstr": "--index",
        }
    )

    bvec_file: os.PathLike = attrs.field(
        metadata={
            "help_string": "diffusion directions",
            "mandatory": True,
            "argstr": "--bvecs",
        }
    )

    bval_file: os.PathLike = attrs.field(
        metadata={
            "help_string": "diffusion weighting",
            "mandatory": True,
            "argstr": "--bvals",
        }
    )

    topup_file: os.PathLike = attrs.field(
        metadata={
            "help_string": "topup output file",
            "mandatory": True,
            "argstr": "--topup",
            "xor": {"fmap_file"},
        }
    )

    fmap_file: os.PathLike = attrs.field(
        metadata={
            "help_string": "fieldmap file",
            "mandatory": True,
            "argstr": "--field",
            "xor": {"topup_file"},
        }
    )

    fmap_matrix: os.PathLike = attrs.field(
        metadata={
            "help_string": "rigid-body transformation matrix from fieldmap to first input volume",
            "argstr": "--field_mat",
            "requires": {"fmap_file"},
        }
    )

    no_peas: bool = attrs.field(
        metadata={
            "help_string": "do not perform post-Eddy alignment of shells",
            "argstr": "--dont_peas",
        }
    )

    # Parameters specifying names of output-files.
    output_basename: str = attrs.field(
        default="eddy",
        metadata={
            "help_string": "basename for output files",
            "argstr": "--out",
        },
    )

    # Parameters specifying how eddy should be run.
    first_level_model: str = attrs.field(
        default="quadratic",
        metadata={
            "help_string": "model for the magnetic field generated by Eddy currents",
            "argstr": "--flm",
            "allowed_values": {"linear", "quadratic", "cubic"},
        },
    )

    second_level_model: str = attrs.field(
        default="none",
        metadata={
            "help_string": "model for how diffusion gradients generate Eddy currents",
            "argstr": "--slm",
            "allowed_values": {"none", "linear", "quadratic"},
        },
    )

    fwhm: float = attrs.field(
        metadata={
            "help_string": (
                "filter width used for pre-conditionning data prior to estimating distortions"
            ),
            "argstr": "--fwhm",
        }
    )

    num_iterations: int = attrs.field(
        default=5,
        metadata={
            "help_string": "number of iterations for eddy",
            "argstr": "--niter",
        },
    )

    fill_empty_planes: bool = attrs.field(
        metadata={
            "help_string": "detect and fill empty planes",
            "argstr": "--fep",
        }
    )

    interpolation: str = attrs.field(
        default="spline",
        metadata={
            "help_string": "interpolation method for the estimation phase",
            "argstr": "--interp",
            "allowed_values": {"spline", "trilinear"},
        },
    )

    resampling: str = attrs.field(
        default="jac",
        metadata={
            "help_string": "final resampling strategy",
            "argstr": "--resamp",
            "allowed_values": {"jac", "lsr"},
        },
    )

    num_voxels: int = attrs.field(
        default=1000,
        metadata={
            "help_string": "number of voxels to use for GP hyperparameter estimation",
            "argstr": "--nvoxhp",
        },
    )

    fudge_factor: int = attrs.field(
        default=10,
        metadata={
            "help_string": "fudge factor for Q-space smoothing during estimation",
            "argstr": "--ff",
        },
    )

    # Parameters for outlier replacement (ol)
    replace_outliers: bool = attrs.field(
        metadata={"help_string": "replace outliers", "argstr": "--repol"}
    )

    ol_num_std: int = attrs.field(
        metadata={
            "help_string": "number of std off to qualify as outlier",
            "argstr": "--ol_nstd",
            "requires": {"replace_outliers"},
        }
    )

    ol_num_voxels: int = attrs.field(
        metadata={
            "help_string": "minimum number of voxels in a slice to qualify for outlier detection",
            "argstr": "--ol_nvox",
            "requires": {"replace_outliers"},
        }
    )

    ol_type: str = attrs.field(
        metadata={
            "help_string": "type of outliers detected",
            "argstr": "--ol_type",
            "allowed_values": {"both", "gw", "sw"},
            "requires": {"replace_outliers"},
        }
    )

    multiband_factor: int = attrs.field(
        metadata={
            "help_string": "multiband factor",
            "argstr": "--mb",
        }
    )

    multiband_offset: int = attrs.field(
        metadata={
            "help_string": "multiband slice offset",
            "argstr": "--mb_offs",
            "requires": {"multiband_factor"},
        }
    )

    # Parameters for intra-volume movement correction (s2v)
    temporal_order: int = attrs.field(
        default=0,
        metadata={
            "help_string": "order of movement model",
            "argstr": "--mporder",
        },
    )

    s2v_num_iterations: int = attrs.field(
        metadata={
            "help_string": "number of iterations for s2v movement estimation",
            "argstr": "--s2v_niter",
        }
    )

    s2v_lambda: float = attrs.field(
        metadata={
            "help_string": "weighting of regularization for s2v movement estimation",
            "argstr": "--s2v_lambda",
        }
    )

    s2v_interpolation: str = attrs.field(
        metadata={
            "help_string": "interpolation method for s2v movement estimation.",
            "argstr": "--s2v_interp",
        }
    )

    slice_grouping_file: os.PathLike = attrs.field(
        metadata={
            "help_string": "file containing slice grouping information",
            "argstr": "--slspec",
            "xor": {"slice_timing_file"},
        }
    )

    slice_timing_file: os.PathLike = attrs.field(
        metadata={
            "help_string": "file containing slice timing information",
            "argstr": "--json",
            "xor": {"slice_grouping_file"},
        }
    )

    # Parameters for move-by-susceptibility correction (mbs)
    estimate_move_by_susceptibility: bool = attrs.field(
        metadata={
            "help_string": "estimate susceptibility-induced field changes due to subject motion",
            "argstr": "--estimate_move_by_susceptibility",
        }
    )

    mbs_num_iterations: int = attrs.field(
        metadata={
            "help_string": "number of iterations for MBS field estimation",
            "argstr": "--mbs_niter",
            "requires": {"estimate_move_by_susceptibility"},
        }
    )

    mbs_lambda: int = attrs.field(
        metadata={
            "help_string": "weighting of regularization for MBS field estimation",
            "argstr": "--mbs_lambda",
            "requires": {"estimate_move_by_susceptibility"},
        }
    )

    mbs_knot_spacing: int = attrs.field(
        metadata={
            "help_string": "knot-spacing for MBS field estimation",
            "argstr": "--mbs_ksp",
            "requires": {"estimate_move_by_susceptibility"},
        }
    )

    # Miscellaneous parameters.
    data_is_shelled: bool = attrs.field(
        metadata={
            "help_string": "bypass checks for data shelling",
            "argstr": "--data_is_shelled",
        }
    )

    random_seed: int = attrs.field(
        metadata={
            "help_string": "random seed for voxel selection",
            "argstr": "--initrand",
        }
    )


class Eddy(pydra.engine.ShellCommandTask):
    """Task definition for eddy."""

    input_spec = pydra.specs.SpecInfo(name="EddyInput", bases=(EddySpec,))

    executable = "eddy"
